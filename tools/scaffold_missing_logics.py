#!/usr/bin/env python3
"""
Scaffold Missing Logics — Task P1.5.3

Reads artifacts/master_vs_repo_report.json and creates contract-only stub files
for any entries listed under `missing_in_repo`.

Deterministic-first: output is stable; file contents have no timestamps; ordering
is by (id, slug). Existing files are never overwritten.

Exit codes:
- 0: success (including no-op)
- 2: errors (invalid inputs, write failures, interactive confirmation missing)
"""

from __future__ import annotations

import argparse
import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List


ROOT = Path(__file__).resolve().parents[1]
ARTIFACTS_DIR = ROOT / "artifacts"
LOGICS_DIR = ROOT / "logics"
REPORT_PATH = ARTIFACTS_DIR / "master_vs_repo_report.json"
MASTER_INDEX_PATH = ARTIFACTS_DIR / "master_index.json"


@dataclass(frozen=True)
class MissingItem:
    id: int
    slug: str
    expected_path: str


def read_json(path: Path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def load_missing(report_path: Path) -> List[MissingItem]:
    report = read_json(report_path)
    items: List[MissingItem] = []
    for obj in sorted(
        report.get("missing_in_repo", []), key=lambda x: (int(x["id"]), x["slug"])
    ):
        items.append(
            MissingItem(
                id=int(obj["id"]),
                slug=str(obj["slug"]),
                expected_path=str(obj["expected_path"]),
            )
        )
    return items


def index_title_by_id(master_index_path: Path) -> dict:
    index = read_json(master_index_path)
    # Ensure ids are ints in mapping
    return {int(entry["id"]): entry.get("title", "") for entry in index}


def build_stub_content(logic_id: int, title: str, slug: str) -> str:
    # Deterministic, minimal, contract-only stub template
    header = (
        '"""'
        + f"\nLogic ID: {logic_id:03d}\n"
        + f"Title   : {title}\n"
        + "Source  : MASTER_SCOPE_OF_WORK (authoritative index)\n"
        + "Note    : Contract-only stub generated by scaffold (P1.5.3). Replace with implementation in later phases.\n"
        + '"""\n'
    )
    body = (
        "from __future__ import annotations\n"
        "from typing import Any, Dict\n\n"
        "# Contract-only entrypoint shape placeholder\n"
        "def execute(inputs: Dict[str, Any]) -> Dict[str, Any]:\n"
        "    # Deterministic no-op output; keeps shape expectations minimal.\n"
        f'    return {{"sections": {{}}, "alerts": [], "meta": {{"id": {logic_id}, "slug": "{slug}"}}}}\n'
    )
    return header + body


def ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def write_file(path: Path, content: str) -> None:
    ensure_parent(path)
    # Do not overwrite existing files
    if path.exists():
        return
    with open(path, "w", encoding="utf-8", newline="\n") as f:
        f.write(content)
        # Enforce newline at EOF
        if not content.endswith("\n"):
            f.write("\n")


def main(argv: List[str]) -> int:
    parser = argparse.ArgumentParser(
        description="Scaffold missing logic stubs from artifacts/master_vs_repo_report.json"
    )
    parser.add_argument(
        "--report",
        type=Path,
        default=REPORT_PATH,
        help="Path to master_vs_repo_report.json",
    )
    parser.add_argument(
        "--master-index",
        type=Path,
        default=MASTER_INDEX_PATH,
        help="Path to master_index.json (for titles)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print planned creations without writing files",
    )
    parser.add_argument(
        "--yes", action="store_true", help="Proceed without interactive confirmation"
    )
    args = parser.parse_args(argv)

    try:
        missing = load_missing(args.report)
        if not missing:
            # Nothing to do — deterministic no-op
            return 0

        title_by_id = index_title_by_id(args.master_index)

        # Deterministic order already ensured by load_missing sort
        planned_paths: List[Path] = []
        for item in missing:
            rel_path = Path(item.expected_path)
            # Normalize to repo root
            if rel_path.is_absolute():
                # Force relative under repo
                rel_path = Path("logics") / rel_path.name
            planned_paths.append(ROOT / rel_path)

        if args.dry_run:
            for item, abs_path in zip(missing, planned_paths):
                print(f"CREATE {abs_path.relative_to(ROOT).as_posix()}")
            return 0

        if not args.yes:
            sys.stderr.write(
                "ERROR: Refusing to write without --yes. Use --dry-run to preview.\n"
            )
            return 2

        # Create stubs
        for item, abs_path in zip(missing, planned_paths):
            title = title_by_id.get(item.id, "")
            content = build_stub_content(item.id, title, item.slug)
            # Never overwrite existing files
            write_file(abs_path, content)

        return 0
    except Exception as exc:
        sys.stderr.write(f"ERROR: {exc}\n")
        return 2


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
